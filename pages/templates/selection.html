<!DOCTYPE html>
<html lang="en">
<head>
    <!-- load JS libraries (copied from UMBC_StreetMap.html to make map dynamic) -->
    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.3/dist/leaflet.js"></script>
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Leaflet.awesome-markers/2.0.2/leaflet.awesome-markers.js"></script>

    <!-- load CSS libraries -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.3/dist/leaflet.css"/>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.2/dist/css/bootstrap.min.css"/>
    <link rel="stylesheet" href="https://netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap-glyphicons.css"/>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.2.0/css/all.min.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/Leaflet.awesome-markers/2.0.2/leaflet.awesome-markers.css"/>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/python-visualization/folium/folium/templates/leaflet.awesome.rotate.min.css"/>

    <meta charset="UTF-8" />
    <!-- adjust screen on mobile devices -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Selection</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='selection.css') }}">
</head>
<body>
    <div id="map"></div>

    <!-- left side bar with buttons -->
    <div id="leftSidebar">
        <!-- logo and divider line -->
        <div class="logo-block">
            <div class="umbc-logo" id="UMBCSidebarBtn">
                <img class="umbc-logo" 
                src="/static/umbc.png" 
                alt="UMBC logo"
                onclick="window.open('https://sds.umbc.edu/', '_blank')"
                style="cursor: pointer;">
            </div>

            <div class="sidebar-divider"></div>
        </div>

        <!-- starred routes button -->
        <div class="sidebar-item" onclick="openStarredRoutes()">
            <img src="/static/star.png" alt="Saved">
            <span>Saved</span>
        </div>

        <!-- alerts button -->
        <div class="sidebar-item" id="alertsSidebarBtn">
            <img src="/static/warning.png" alt="Alerts">
            <span>Alerts</span>
        </div>

        <!-- settings button -->
        <div class="sidebar-item" id="settingsSidebarBtn">
            <img src="/static/gear.png" alt="Settings">
            <span>Settings</span>
        </div>

        <!-- reports button (admin only) -->
        {% if is_admin %}
        <div class="sidebar-item" id="reportsSidebarBtn">
            <img src="/static/tools.png" alt="Reports">
            <span>Reports</span>
        </div>
        {% endif %}
    </div>

    <!-- route search form -->
    <div class="inputs">
        <form id="routeForm" action="/map" method="POST" class="routeForm">
            <!-- start location dropdown -->
            <select id="startLocation" name="startLocation" required>
                <option value="" disabled selected>Start Location</option>
                {% for building in buildings %}
                <option value="{{ building }}">{{ building }}</option>
                {% endfor %}
            </select>

            <!-- end location dropdown -->
            <select id="endLocation" name="endLocation" required>
                <option value="" disabled selected>End Location</option>
                {% for building in buildings %}
                <option value="{{ building }}">{{ building }}</option>
                {% endfor %}
            </select>

            <!-- submit button -->
            <button type="submit" id="startSearch">Search</button>
        </form>
    </div>

    <div class="zoomControls">
        <!-- bottom right zoom buttons -->
        <img src="{{ url_for('static', filename='user_zoom.png') }}" onclick="zoomToUser()">
        <img src="{{ url_for('static', filename='campus_zoom.png') }}" onclick="zoomUMBC()">
    </div>

    <!-- settings popup -->
    <div id="settings-popup" class="popup2">
        <button id="close-settings-popup" class="close-btn">×</button>
        <div class="popup-content">
            <h2>Settings</h2>
            <div class="setting-item">
                <label>
                    <input type="checkbox" id="toggle-voice">
                    Voice Commands
                </label>
            </div>

            <div class="setting-item">
                <label>
                    <input type="checkbox" id="toggle-directions">
                    Live Directions
                </label>
            </div>

            <div class="setting-item">
                <label>
                    <input type="checkbox" id="toggle-theme">
                    Dark Mode
                </label>
            </div>
        </div>
    </div>

    <!-- admin alerts popup -->
    <div id="admin-alerts-popup" class="popup">
        <div class="popup-content">
            <button id="close-alert-popup" class="close-btn">×</button>
            <h2>Alerts</h2>

            <div id="alerts-list"></div>

            {% if is_admin %}
            <div class="admin-alert-create-row">
                <input type="text" id="alert-text" placeholder="Enter alert message" class="alert-input">
                <button id="submit-alert-btn" class="btn-create">Create</button>
            </div>
            {% endif %}
        </div>
    </div>

    <!-- starred routes popup -->
    <div id="starredRoutesModal" class="modal">
        <div class="modal-content">
            <span class="close-btn" onclick="closeStarredRoutesModal()">&times;</span>
            <h2>Your Starred Routes</h2>
            <div id="starredRoutesList"></div>
        </div>
    </div>

    <!-- generates routes popup -->
    {% if routes %}
    <div class="routesBlock" id="routesBlock">
        {% for rank, route in routes.items() %}
        <div class="routeCard" id="route-{{ rank }}" onclick="selectRoute('{{ rank }}')">
            <div class="routeHeaderRow">
                <div class="routeHeader">
                  {{ route.time_min }} min <span>({{ route.meters }} m)</span>
                </div>
                <img id="star-{{ rank }}"
                     src="{{ url_for('static', filename='FavFill.png') }}"
                     data-starred="false"
                     class="routeStar">
            </div>

            <div class="routeSubtitleRow">
                <div class="routeSubtitle">
                    {% if loop.index == 1 %}
                        Fastest route
                    {% else %}
                        Alternative route
                    {% endif %}
                </div>
                <img src="{{ url_for('static', filename='accessible.png') }}"
                     alt="Accessible"
                     class="accessibleIcon">
            </div>
        </div>
        {% endfor %}
        <button id="startButton" class="startBtn">Start</button>
    </div>
    {% endif %}

    <div id="directionsBox"></div>

    <!-- direction mode buttons -->
    <div id="directionControls">
        <img id="prevDirection" src="{{ url_for('static', filename='prev.png') }}">
        <img id="exitDirections" src="{{ url_for('static', filename='exit.png') }}">
        <img id="nextDirection" src="{{ url_for('static', filename='next.png') }}">
    </div>

    <script>
        // get user's current settings data from db
        let USER_MODE = "{{ mode }}";
        let USER_LIVE_UPDATES = {{ 'true' if live_updates else 'false' }};
        let USER_VOICE_OVER = {{ 'true' if voice_over else 'false' }};

        document.addEventListener("DOMContentLoaded", () => {
            const collapsed = document.getElementById("search-collapsed");
            const expanded = document.getElementById("search-expanded");

            collapsed.addEventListener("click", () => {
                collapsed.style.display = "none";
                expanded.style.display = "block";
            });
        });

        // listener for alerts popup
        document.addEventListener("DOMContentLoaded", () => {
            const closeBtn = document.getElementById("close-alert-popup");
            const popup = document.getElementById("admin-alerts-popup");

            if (closeBtn) {
                closeBtn.addEventListener("click", () => {
                    popup.style.display = "none";
                });
            };
        });

        // listener for settings popup
        document.addEventListener("DOMContentLoaded", () => {
            const settingsPopup = document.getElementById("settings-popup");
            const openBtn = document.getElementById("settingsSidebarBtn");
            const closeBtn = document.getElementById("close-settings-popup");

            const voiceToggle = document.getElementById("toggle-voice");
            const directionsToggle = document.getElementById("toggle-directions");
            const themeToggle = document.getElementById("toggle-theme");

            // initialize boxes from db values
            voiceToggle.checked = USER_VOICE_OVER;
            directionsToggle.checked = USER_LIVE_UPDATES;
            themeToggle.checked = (USER_MODE === "dark");

            // apply theme immediately
            if (USER_MODE === "dark") {
                document.body.classList.add("dark-mode");
            } else {
                document.body.classList.remove("dark-mode");
            }

            // open settings popup
            openBtn.addEventListener("click", () => settingsPopup.style.display = "flex");

            // close popup and save settings
            closeBtn.addEventListener("click", async () => {
                settingsPopup.style.display = "none";

                const mode = themeToggle.checked ? "dark" : "light";
                const live_updates = directionsToggle.checked;
                const voice_over = voiceToggle.checked;

                try {
                    const resp = await fetch("/update-settings", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ mode, live_updates, voice_over })
                    });
                    const data = await resp.json();
                    if (data.success) {
                        console.log("Settings updated successfully!");
                        USER_MODE = mode;
                        USER_LIVE_UPDATES = live_updates;
                        USER_VOICE_OVER = voice_over;
                    } else {
                        alert("Error updating settings: " + data.error);
                    }
                } catch (err) {
                    console.error("Error saving settings:", err);
                    alert("Error saving settings.");
                }
            });

            // voice commands checkbox
            voiceToggle.addEventListener("change", () => {
                if (voiceToggle.checked) {
                    console.log("Voice commands enabled");
                } else {
                    console.log("Voice commands disabled");
                }
            });

            // live directions checkbox
            directionsToggle.addEventListener("change", () => {
                if (directionsToggle.checked) {
                    console.log("Live directions enabled");
                } else {
                    console.log("Live directions disabled");
                }
            });

            // theme checkbox
            themeToggle.addEventListener("change", () => {
                if (themeToggle.checked) {
                    document.body.classList.add("dark-mode");
                    console.log("Dark mode enabled");
                } else {
                    document.body.classList.remove("dark-mode");
                    console.log("Light mode enabled");
                }
            });
        });

        // check if user clicks alerts button
        document.addEventListener("DOMContentLoaded", () => {
            const warningIcon = document.getElementById("alertsSidebarBtn");
            if (!warningIcon) return;

            warningIcon.addEventListener("click", async () => {
                try {
                    const resp = await fetch("/alerts");
                    if (!resp.ok) {
                        alert("Failed to fetch alerts.");
                        return;
                    }
                    const alerts = await resp.json();

                    const popup = document.getElementById("admin-alerts-popup");
                    const listDiv = document.getElementById("alerts-list");
                    listDiv.innerHTML = "";

                    if (!alerts.length) {
                        listDiv.textContent = "No alerts at this time.";
                    } else {
                        // show the date, time and text for each alert
                        alerts.forEach(a => {
                            const wrapper = document.createElement("div");
                            wrapper.className = "alert-item";

                            const timestamp = document.createElement("span");
                            timestamp.className = "alert-timestamp";
                            timestamp.textContent = `[${new Date(a.created_at).toLocaleString()}] `;

                            const alertText = document.createElement("span");
                            alertText.className = "alert-text";
                            alertText.textContent = a.alert_text;

                            wrapper.appendChild(timestamp);
                            wrapper.appendChild(alertText);

                            // show red X for admins
                            {% if is_admin %}
                            const delBtn = document.createElement("span");
                            delBtn.textContent = "✖";
                            delBtn.style.color = "red";
                            delBtn.style.cursor = "pointer";
                            delBtn.style.marginLeft = "10px";
                            delBtn.addEventListener("click", async () => {
                                if (!confirm("Delete this alert?")) return;
                                const resp = await fetch(`/delete-alert/${a.id}`, { method: "DELETE" });
                                const data = await resp.json();
                                if (data.success) {
                                    wrapper.remove();
                                } else {
                                    alert("Error deleting alert: " + data.error);
                                }
                            });
                            wrapper.appendChild(delBtn);
                            {% endif %}

                            listDiv.appendChild(wrapper);
                        });
                    }

                    popup.style.display = "flex";
                } catch (err) {
                    console.error("Error fetching alerts:", err);
                    alert("Error loading alerts.");
                }
            });
        });

        var activeStarredRouteId = null;
        var activeStarredRouteLayer = null;
        window.starredRoutes = [];
        window.normalizedStarredRoutes = [];

        // make sure starred route format is correct
        function normalizeStarredRoute(route) {
            if (!route.routes_geometry || !Array.isArray(route.routes_geometry)) return null;

            const geoms = route.routes_geometry.map((line, index) => ({
                seq: index,
                geom: line
            }));

            return {
                ...route,
                geoms: geoms,
                pgr_path_id: null,
                meters: null,
                time_min: null,
                rank: 'starred-' + route.id
            };
        }

        // open starred routes popup
        async function openStarredRoutes() {
            try {
                const resp = await fetch("/get-starred-routes");
                if (!resp.ok) throw new Error("Failed to fetch starred routes");

                const starredRoutes = await resp.json();
                
                populateStarredRoutesList(starredRoutes);

                document.getElementById("starredRoutesModal").style.display = "block";

            } catch (err) {
                console.error("Error loading starred routes:", err);
                alert("Failed to load starred routes.");
            }
        }

        // close starred routes popup
        function closeStarredRoutesModal() {
            document.getElementById('starredRoutesModal').style.display = 'none';
        }

        // show list of all starred routes
        function populateStarredRoutesList(routes) {
            const listDiv = document.getElementById('starredRoutesList');
            listDiv.innerHTML = '';

            if (!routes || routes.length === 0) {
                listDiv.innerHTML = '<p>You have no starred routes.</p>';
                return;
            }

            routes.forEach(route => {
                const row = document.createElement('div');
                row.className = 'starred-item';
                row.id = 'starred-' + route.id;

                const nameDiv = document.createElement('div');
                nameDiv.textContent = route.custom_name;
                nameDiv.style.cursor = 'pointer';
                nameDiv.onclick = (event) => {
                    event.stopPropagation();
                    handleSelectStarredRoute(route);
                };

                const deleteX = document.createElement('div');
                deleteX.textContent = "✖";
                deleteX.style.color = "red";
                deleteX.style.cursor = 'pointer';
                deleteX.onclick = (event) => {
                    event.stopPropagation();
                    deleteStarredRoute(route.id);
                };

                row.appendChild(nameDiv);
                row.appendChild(deleteX);
                listDiv.appendChild(row);
            });
        }

        function normalizeFeatureCollection(fc) {
            return {
                type: "FeatureCollection",
                features: fc.features.map(f => {
                let geom = f.geometry;
                if (typeof geom === "string") {
                    try {
                    geom = JSON.parse(geom);
                    } catch (e) {
                    console.error("Failed to parse geometry:", geom, e);
                    }
                }
                return { ...f, geometry: geom };
                })
            };
            }

        async function handleSelectStarredRoute(routeSummary) {
            console.log("Selected starred route:", routeSummary);

            closeStarredRoutesModal();

            if (routeGroup) { map.removeLayer(routeGroup); routeGroup = null; }
            if (activeStarredRouteLayer) { map.removeLayer(activeStarredRouteLayer); activeStarredRouteLayer = null; }

            document.querySelectorAll(".routeCard.selected").forEach(card => card.classList.remove("selected"));
            selectedRoute = null;

            document.querySelectorAll(".starred-item.selected").forEach(item => item.classList.remove("selected"));

            const selectedItem = document.getElementById("starred-" + routeSummary.id);
            if (selectedItem) selectedItem.classList.add("selected");

            activeStarredRouteId = routeSummary.id;

            try {
                // fetch full route object, including route nodes or directions
                const resp = await fetch(`/get-starred-route/${routeSummary.id}`);
                const routeData = await resp.json();

                if (!routeData || (!routeData.route_nodes && !routeData.directions)) {
                    alert("Starred route data is incomplete.");
                    return;
                }

                const normalizedGeoJSON = normalizeFeatureCollection(routeData.route_json);

                // store globally for use when clicking "Start"
                window.selectedStarredRoute = {
                    route_json: normalizedGeoJSON,
                    directions: routeData.directions || null
                };

                // show route on map
                showRoute({ routeObj: normalizedGeoJSON });
                startDirections();

            } catch (err) {
                console.error("Failed to fetch starred route:", err);
                alert("Failed to load starred route.");
            }
        }

        // delete starred route
        function deleteStarredRoute(id) {
            fetch('/delete_starred_route', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ id })
            })
            .then(res => res.json())
            .then(data => {
                if (data.success) {
                    fetch('/get-starred-routes')
                    .then(r => r.json())
                    .then(routes => {
                        window.starredRoutes = routes;
                        populateStarredRoutesList(routes);
                    });

                    if (activeStarredRouteId === id && activeStarredRouteLayer) {
                        map.removeLayer(activeStarredRouteLayer);
                        activeStarredRouteLayer = null;
                        activeStarredRouteId = null;
                    }

                    alert("Route removed from starred list.");
                }
            })
            .catch(err => console.error('Delete error:', err));
        }
    </script>

    {% if is_admin %}
    <!-- admin reports popup -->
    <div id="admin-reports-popup" class="popup">
        <div class="popup-content">
            <button id="close-admin-popup" class="close-btn">×</button>
            <h2>Reported Nodes (Last 30 Days)</h2>
            <div id="reported-nodes-list"></div>
        </div>
    </div>
    
    <script>
        // listen for if admin opens alerts
        document.addEventListener("DOMContentLoaded", () => {
            const createBtn = document.getElementById("create-alert-btn");
            const popup = document.getElementById("admin-alerts-popup");
            const closeBtn = document.getElementById("close-alert-popup");
            const submitBtn = document.getElementById("submit-alert-btn");

            if (createBtn) {
                createBtn.addEventListener("click", () => popup.style.display = "block");
            }
            if (closeBtn) {
                closeBtn.addEventListener("click", () => popup.style.display = "none");
            }
            if (submitBtn) {
                submitBtn.addEventListener("click", async () => {
                    const text = document.getElementById("alert-text").value.trim();
                    if (!text) {
                        alert("Please enter an alert message.");
                        return;
                    }
                    const resp = await fetch("/create-alert", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ alert_text: text })
                    });
                    const data = await resp.json();
                    if (data.success) {
                        alert("Alert created successfully!");
                        document.getElementById("alert-text").value = "";
                        popup.style.display = "none";
                    } else {
                        alert("Error creating alert: " + data.error);
                    }
                });
            }
        });

        reportNodes = [];
        let currentHighlight = null;

        // highlights passed node on the map
        function highlightNodeOnMap(nodeId) {
            const node = reportNodes.find(n => n.node_id == nodeId);
            if (!node) {
                console.error("Node not found:", nodeId);
                return;
            }

            document.getElementById("admin-reports-popup").style.display = "none";

            if (currentHighlight) {
                map.removeLayer(currentHighlight);
                currentHighlight = null;
            }

            const latlng = [node.lat, node.lng];
            map.setView(latlng, 19);

            currentHighlight = L.circleMarker(latlng, {
                radius: 30,
                color: "red",
                weight: 8,
                opacity: 0.2,
                fillOpacity: 0.5,
                className: "highlight-halo"
            }).addTo(map);
        }

        // temporarily removes node from map
        function removeNodeFromMap(nodeId) {
            fetch(`/admin/remove-node/${nodeId}`, {
                method: "POST",
                headers: { "Content-Type": "application/json" }
            })
            .then(res => res.json())
            .then(data => {
                if (data.success) {
                    alert("Node removed successfully.");
                    loadReports();
                } else {
                    console.error("Remove node failed:", data.error);
                    alert("Error removing node: " + (data.error || ""));
                }
            });
        }

        // restore removed node on the map
        function restoreNodeOnMap(nodeId) {
            fetch(`/admin/restore-node/${nodeId}`, {
                method: "POST",
                headers: { "Content-Type": "application/json" }
            })
            .then(res => res.json())
            .then(data => {
                if (data.success) {
                    alert("Node restored successfully.");
                    loadReports();
                } else {
                    alert("Error restoring node.");
                }
            });
        }

        // listen for if admin clicks reports button
        document.addEventListener("DOMContentLoaded", () => {
            const btn = document.getElementById("reportsSidebarBtn");
            const popup = document.getElementById("admin-reports-popup");
            const closeBtn = document.getElementById("close-admin-popup");
            const listDiv = document.getElementById("reported-nodes-list");

            // load all user reports in order of number of reports
            function loadReports() {
                if (!listDiv) return;
                listDiv.innerHTML = "";

                fetch("/admin/report-summary")
                    .then(res => res.json())
                    .then(data => {
                        if (!Array.isArray(data)) {
                            console.error("Report summary error:", data);
                            alert("Error loading report summary.");
                            return;
                        }

                        reportNodes = data;

                        data.forEach(node => {
                            const nodeDiv = document.createElement("div");
                            nodeDiv.style.marginBottom = "25px";
                            if (!node.in_use) nodeDiv.classList.add("removed-node");

                            const actionIcon = node.in_use
                                ? `<i class="fa fa-times remove-node"
                                    style="cursor:pointer; margin-left:10px; color:#dc3545;"
                                    data-node-id="${node.node_id}"></i>`
                                : `<i class="fa fa-check restore-node"
                                    style="cursor:pointer; margin-left:10px; color:#28a745;"
                                    data-node-id="${node.node_id}"></i>`;

                            nodeDiv.innerHTML = `
                                <h4>
                                    ${node.building} ${node.name} — ${node.report_count} reports
                                    <i class="fa fa-eye view-node"
                                    style="cursor:pointer; margin-left:10px;"
                                    data-node-id="${node.node_id}"></i>
                                    ${actionIcon}
                                </h4>
                            `;

                            const table = document.createElement("table");
                            table.classList.add("report-table");
                            table.innerHTML = `
                                <thead>
                                    <tr>
                                        <th>Email</th>
                                        <th>Date</th>
                                        <th>Description</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${node.reports.map(r => `
                                        <tr>
                                            <td>${r.email}</td>
                                            <td>${new Date(r.reported_at).toLocaleString()}</td>
                                            <td>${r.description || ""}</td>
                                        </tr>`).join("")}
                                </tbody>
                            `;
                            nodeDiv.appendChild(table);
                            listDiv.appendChild(nodeDiv);

                            // eye handler
                            nodeDiv.querySelector(".view-node").addEventListener("click", e => {
                                highlightNodeOnMap(e.currentTarget.dataset.nodeId);
                            });

                            // remove or restore handler
                            if (node.in_use) {
                                nodeDiv.querySelector(".remove-node").addEventListener("click", e => {
                                    const nodeId = e.currentTarget.dataset.nodeId;
                                    if (confirm("Are you sure you want to remove this node from the map?")) {
                                        fetch(`/admin/remove-node/${nodeId}`, {
                                            method: "POST",
                                            headers: { "Content-Type": "application/json" }
                                        })
                                        .then(res => res.json())
                                        .then(data => {
                                            if (data.success) {
                                                alert("Node removed successfully.");
                                                loadReports();
                                            } else {
                                                alert("Error removing node: " + (data.error || ""));
                                            }
                                        });
                                    }
                                });
                            } else {
                                nodeDiv.querySelector(".restore-node").addEventListener("click", e => {
                                    const nodeId = e.currentTarget.dataset.nodeId;
                                    if (confirm("Are you sure you want to restore this node?")) {
                                        fetch(`/admin/restore-node/${nodeId}`, {
                                            method: "POST",
                                            headers: { "Content-Type": "application/json" }
                                        })
                                        .then(res => res.json())
                                        .then(data => {
                                            if (data.success) {
                                                alert("Node restored successfully.");
                                                loadReports();
                                            } else {
                                                alert("Error restoring node.");
                                            }
                                        });
                                    }
                                });
                            }
                        });

                    popup.style.display = "flex";
                });
            }

            btn.addEventListener("click", loadReports);
            closeBtn.addEventListener("click", () => popup.style.display = "none");
            popup.addEventListener("click", e => { if (e.target === popup) popup.style.display = "none"; });
        });
    </script>
    {% endif %}

    <script>
        let directionMode = false;
        let currentStep = 0;
        let directions = [];

        // calculate distance in meters
        function haversineDistance(lat1, lng1, lat2, lng2) {
            const R = 6371000;
            const toRad = deg => deg * Math.PI / 180;
            const dLat = toRad(lat2 - lat1);
            const dLng = toRad(lng2 - lng1);
            const a = Math.sin(dLat/2)**2 +
                    Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
                    Math.sin(dLng/2)**2;
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // calculate direction difference between two edges
        function bearing(lat1, lng1, lat2, lng2) {
            const toRad = deg => deg * Math.PI / 180;
            const toDeg = rad => rad * 180 / Math.PI;
            const dLng = toRad(lng2 - lng1);
            const y = Math.sin(dLng) * Math.cos(toRad(lat2));
            const x = Math.cos(toRad(lat1)) * Math.sin(toRad(lat2)) -
                    Math.sin(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.cos(dLng);
            return (toDeg(Math.atan2(y, x)) + 360) % 360;
        }

        // calculate angle difference between two bearings
        function angleDiff(b1, b2) {
            let diff = b2 - b1;
            if (diff > 180) diff -= 360;
            if (diff < -180) diff += 360;
            return diff;
        }

        // given a path's nodes, generate the directions
        function generateDirections(nodes){
            let directions = [];
            let straightFeet = 0;
            let dirNode = nodes[0];

            for (i = 0; i < nodes.length - 1; i++){
                const curr = nodes[i];
                const next = nodes[i + 1];
                const distMeters = haversineDistance(curr.lat, curr.lng, next.lat, next.lng);
                const distFeet = Math.round(distMeters * 3.28084);

                const b1 = bearing(curr.lat, curr.lng, next.lat, next.lng);

                if (i + 2 < nodes.length){
                    const next2 = nodes[i + 2];

                    const b2 = bearing(next.lat, next.lng, next2.lat, next2.lng);
                    const a = angleDiff(b1, b2);
                    let turn = "";

                    if (a > 50){
                        turn = "turn right";
                    } else if (a < -50) {
                        turn = "turn left";
                    } else {
                        turn = "none";
                    }

                    let pushed = false;

                    if (!pushed && curr.type === 'elevator' && next.type === 'indoor'){
                        let elevatorText = "";
                        if (turn === "none"){
                            elevatorText = "Exit the elevator and walk straight.";
                        } else {
                            elevatorText = `Exit the elevator and ${turn}.`;
                        }
                        
                        directions.push({
                            nodeIndex: i,
                            text: elevatorText,
                            lat: curr.lat,
                            lng: curr.lng
                        });
                        straightFeet = 0;
                        pushed = true;
                        dirNode = next;
                    }

                    if (!pushed && curr.type === "indoor" && next.type === "elevator") {
                        directions.push({
                            nodeIndex: i + 1,
                            text: `Use the elevator to go to the ${next2.floor} floor.`,
                            lat: next.lat,
                            lng: next.lng,
                        })
                        straightFeet = 0;
                        pushed = true;
                        dirNode = next;
                    }

                    if (!pushed && curr.type != "ramp" && next.type === "ramp") {
                        let rampText = "";
                        straightFeet += distFeet;
                        if (straightFeet > 20 && next.angle === 1){
                            rampText = "Walk straight and go up the ramp.";
                        } else if (straightFeet > 20 && next.angle === -1){
                            rampText = "Walk straight and go down the ramp.";
                        } else {
                            if (next.angle === 1){
                                rampText = "Go up the ramp.";
                            } else if (next.angle === -1){
                                rampText = "Go down the ramp."
                            }
                        }
                        directions.push({
                            nodeIndex: i + 1,
                            text: rampText,
                            lat: curr.lat,
                            lng: curr.lng
                        });
                        straightFeet = 0;
                        pushed = true;
                        dirNode = next;
                    }

                    if (!pushed && curr.type === "ramp" && next.type != "ramp") {
                        if (turn != "none"){
                            straightFeet += distFeet;

                            directions.push({
                                nodeIndex: i,
                                text: `In ${straightFeet} feet, ${turn}.`,
                                lat: dirNode.lat,
                                lng: dirNode.lng
                            });
                            straightFeet = 0;
                            pushed = true;
                            dirNode = next;
                        } else {
                            straightFeet += distFeet;
                        }
                    }

                    if (!pushed && curr.type === "indoor" && next.type === "indoor"){
                        if (turn != "none"){
                            straightFeet += distFeet;
                            directions.push({
                                nodeIndex: i,
                                text: `In ${straightFeet} feet, ${turn}.`,
                                lat: dirNode.lat,
                                lng: dirNode.lng
                            });
                            straightFeet = 0;
                            pushed = true;
                            dirNode = next;
                        } else {
                            straightFeet += distFeet;
                        }
                    }

                    if (!pushed && curr.type === "indoor" && next.type === "entrance"){
                        directions.push({
                                nodeIndex: i,
                                text: `Exit the ${next.building} building.`,
                                lat: curr.lat,
                                lng: curr.lng
                            });
                        straightFeet = 0;
                        pushed = true;
                        dirNode = next;
                    }

                    if (!pushed && curr.type === "entrance" && next.type === "outdoor"){
                        if (turn != "none"){
                            straightFeet += distFeet;
                            directions.push({
                                nodeIndex: i,
                                text: `In ${straightFeet} feet, ${turn}.`,
                                lat: curr.lat,
                                lng: curr.lng
                            });
                            straightFeet = 0;
                            pushed = true;
                            dirNode = next;
                        } else {
                            straightFeet += distFeet;
                        }
                    }

                    if (!pushed && curr.type === "outdoor" && next.type === "outdoor"){
                        if (turn != "none"){
                            straightFeet += distFeet;
                            directions.push({
                                nodeIndex: i,
                                text: `In ${straightFeet} feet, ${turn}.`,
                                lat: dirNode.lat,
                                lng: dirNode.lng
                            });
                            straightFeet = 0;
                            pushed = true;
                            dirNode = next;
                        } else {
                            straightFeet += distFeet;
                        }
                    }

                    if (!pushed && (curr.type === "outdoor" || curr.type === "ramp") && next.type === "entrance"){
                        let enterText = "";
                        if (straightFeet > 20){
                            enterText = `Walk straight and enter the ${next.building} building.`;
                        } else if (curr.type === "ramp" && next2.type === "outdoor") {
                            enterText = `Exit the ${next.building} building.`
                        } else {
                            enterText = `Enter the ${next.building} building.`;
                        }
                        directions.push({
                            nodeIndex: i,
                            text: enterText,
                            lat: curr.lat,
                            lng: curr.lng
                        });
                        pushed = true;
                        dirNode = next;
                    }

                    if (!pushed && curr.type === "entrance" && next.type === "indoor"){
                        if (turn != "none"){
                            straightFeet += distFeet;
                            directions.push({
                                nodeIndex: i,
                                text: `In ${straightFeet} feet, ${turn}.`,
                                lat: dirNode.lat,
                                lng: dirNode.lng
                            });
                            straightFeet = 0;
                            pushed = true;
                            dirNode = next;
                        } else {
                            straightFeet += distFeet;
                        }
                    }
                } else {
                    directions.push({
                        nodeIndex: i,
                        text: `Take the elevator to the desired floor.`,
                        lat: curr.lat,
                        lng: curr.lng
                    });
                }
            }

            return directions;
        }

        var routes = {{ routes|tojson }};
        console.log("Routes variable:", routes);

        const routesBlock = document.querySelector(".routesBlock");
        const startBtn = document.getElementById("startButton");

        console.log("Route block element:", routesBlock);

        // show the routes block only if there are routes
        if (routes && Object.keys(routes).length > 0) {
        console.log("Showing routes block");
        routesBlock.style.display = "flex";  
        } else {
        console.log("ROUTES EMPTY — block stays hidden");
        }

        async function startDirections(){
            if (!selectedRoute && !window.selectedStarredRoute) {
                alert("No route selected.");
                return;
            }

            directionMode = true;

            // when user clicks start, hide route form and list
            document.querySelector(".inputs").style.display = "none";
            if (routesBlock){
                routesBlock.style.display = "none";
            }
            if (startBtn){
                startBtn.style.display = "none";
            }

            // show directions box and buttons
            const directionsBox = document.getElementById("directionsBox");
            const directionControls = document.getElementById("directionControls");
            directionsBox.style.display = "block";
            directionControls.style.display = "flex";

            let directions = null;

            if (window.selectedStarredRoute) {
                // for starred routes, use the stored directions
                console.log("Using starred route directions:", window.selectedStarredRoute);
                directions = window.selectedStarredRoute.directions;

                if (!directions || directions.length === 0) {
                    alert("Starred route does not have directions.");
                    return;
                }

            } else if (selectedRoute) {
                // for generated route, fetch directions from server
                const pgrId = routes[selectedRoute].pgr_path_id;
                try {
                    const resp = await fetch(`/directions/${pgrId}`);
                    directions = await resp.json();
                    console.log(directions);
                } catch (err) {
                    console.error("Failed to fetch generated route directions:", err);
                    alert("Failed to load generated route.");
                    return;
                }
            }

            directions = generateDirections(directions);
            console.log(directions);
            currentStep = 0;

            function showDirection(step) {
                const d = directions[step];
                const message = `${d.text}`;

                directionsBox.textContent = message;
                map.setView([d.lat, d.lng], 20);

                // if voice commands selected, use text to speech
                if (USER_VOICE_OVER) {
                    const utterance = new SpeechSynthesisUtterance(message);
                    utterance.lang = "en-US";
                    utterance.rate = 1;
                    utterance.pitch = 1;
                    window.speechSynthesis.cancel();
                    window.speechSynthesis.speak(utterance);
                }
            }

            showDirection(currentStep);

        // next handler
        document.getElementById("nextDirection").onclick = function() {
            if (currentStep < directions.length - 1) {
            currentStep++;
            showDirection(currentStep);
            }
        };

        // prev handler
        document.getElementById("prevDirection").onclick = function() {
            if (currentStep > 0) {
            currentStep--;
            showDirection(currentStep);
            }
        };

        // exit handler
        document.getElementById("exitDirections").onclick = function() {
            // reset UI
            const inputs = document.querySelector(".inputs");
            if (inputs) inputs.style.display = "flex";

            if (routesBlock) {
                routesBlock.style.display = "flex";
            }

            const campusZoom = document.querySelector(".zoomControls img[src*='campus_zoom']");
            if (campusZoom) campusZoom.style.display = "inline-block";

            if (startBtn) startBtn.style.display = "inline-block";

            if (directionsBox) directionsBox.style.display = "none";
            if (directionControls) directionControls.style.display = "none";

            currentStep = 0;
        };

        USER_LIVE_UPDATES = true;

        // if live directions option selected, update directions in real-time
        if (USER_LIVE_UPDATES) {
                navigator.geolocation.watchPosition((pos) => {
                    const lat = pos.coords.latitude;
                    const lng = pos.coords.longitude;
                    updateUserMarker(lat, lng);

                    // only auto-advance directions if in direction mode
                    if (directionMode && directions.length > 0) {
                        const nextDir = directions[currentStep];
                        const distance = map.distance([lat, lng], [nextDir.lat, nextDir.lng]);
                        if (distance < 5 && currentStep < directions.length - 1) {
                            showDirection(currentStep);
                            currentStep++;
                        }
                    }
                }, (err) => console.error(err), { enableHighAccuracy: true });
            }
        }
        startBtn.addEventListener("click", startDirections);

        var routes = {{ routes|tojson }};

        var map = L.map('map', {
            zoomControl: false
        }).setView([39.25531911376339, -76.71396732330324], 16);

        L.control.zoom({
            position: 'topright'
        }).addTo(map);

        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 20,
            maxNativeZoom: 19
        }).addTo(map);

        var reportNodes = {{ report_nodes|tojson }};
        var removedNodes = {{ removed_nodes|tojson }};

        // add report markers
        reportNodes.forEach(function(node) {
            var iconUrl = "/static/" + node.type + ".png"; // e.g., elevator.png, door.png
            var icon = L.icon({
                iconUrl: iconUrl,
                iconSize: [32, 32],
                iconAnchor: [16, 16]
            });

            var marker = L.marker([node.lat, node.lng], {icon: icon}).addTo(map);

            marker.on('click', function() {
                showReportForm(node.id, node.type, node.name, node.building, node.lat, node.lng);
            });
        });

        removedNodes.forEach(function(node) {
            var iconUrl = "/static/" + node.type + "_red.png";
            var icon = L.icon({
                iconUrl: iconUrl,
                iconSize: [32, 32],
                iconAnchor: [16, 16]
            });

            var marker = L.marker([node.lat, node.lng], {icon: icon}).addTo(map);

            marker.on('click', function() {
                showFixingBox(node.id, node.type, node.name, node.building, node.lat, node.lng);
            });
        });

        var startIcon = L.icon({
            iconUrl: "/static/start_circle.png",
            iconSize: [48, 48],
            iconAnchor: [24, 24]
        });

        var endIcon = L.icon({
            iconUrl: "/static/end_circle.png",
            iconSize: [48, 48],
            iconAnchor: [24, 24]
        });

        var destinationIcon = L.icon({
            iconUrl: "/static/destination.png",
            iconSize: [48, 48],
            iconAnchor: [24, 48]
        });

        var routeGroup = null;
        var startMarker = null;
        var endMarker = null;
        var destinationMarker = null;

        function pointsEqual(a, b, tol = 1e-6) {
            return Math.abs(a[0] - b[0]) < tol && Math.abs(a[1] - b[1]) < tol;
        }

        // combine edges into one line
        function stitchEdges(features) {
            if (features.length === 0) return [];

            // copy coordinates
            let stitched = features[0].geometry.coordinates.slice();

            // orient the first edge so it connects to the second
            if (features.length > 1) {
                let next = features[1].geometry.coordinates;
                let firstEnd = stitched[stitched.length - 1];
                let nextStart = next[0];
                let nextEnd = next[next.length - 1];

                if (!pointsEqual(firstEnd, nextStart) && !pointsEqual(firstEnd, nextEnd)) {
                // flip the first edge if it doesn't connect
                stitched.reverse();
                }
            }

            // repeat for all other edges
            for (let i = 1; i < features.length; i++) {
                let coords = features[i].geometry.coordinates.slice();
                let prevEnd = stitched[stitched.length - 1];
                let currStart = coords[0];
                let currEnd = coords[coords.length - 1];

                if (pointsEqual(prevEnd, currStart)) {
                    stitched = stitched.concat(coords.slice(1));
                } else if (pointsEqual(prevEnd, currEnd)) {
                        coords.reverse();
                stitched = stitched.concat(coords.slice(1));
                } else {
                    console.warn("Edge does not connect properly:", features[i]);
                }
            }

            return stitched;
        }

        function showRoute({ rank = null, routeObj = null }) {
            // remove any existing routes or markers
            if (activeStarredRouteLayer) { map.removeLayer(activeStarredRouteLayer); activeStarredRouteLayer = null; }
            if (routeGroup) { map.removeLayer(routeGroup); routeGroup = null; }
            if (startMarker) { map.removeLayer(startMarker); startMarker = null; }
            if (endMarker) { map.removeLayer(endMarker); endMarker = null; }
            if (destinationMarker) { map.removeLayer(destinationMarker); destinationMarker = null; }

            const route = routeObj || (rank ? routes[rank] : null);
            if (!route) return;

            let featureCollection;

            if (route.geoms) {
                // for generated route, build features from geoms
                const features = route.geoms
                    .sort((a, b) => a.seq - b.seq)
                    .map(g => ({
                        type: "Feature",
                        geometry: (typeof g.geom === "string") ? JSON.parse(g.geom.replace(/'/g,'"')) : g.geom
                    }));
                featureCollection = { type: "FeatureCollection", features };
            } else {
                // for starred route, assume routeObj is already GeoJSON FeatureCollection
                featureCollection = route;
            }
            console.log("FeatureCollection:", featureCollection);
            featureCollection.features.forEach((f, i) => {
            console.log("Feature", i, "geometry type:", typeof f.geometry, f.geometry);
            });

            // create a new layer for route
            const layer = L.featureGroup();
            if (routeObj) activeStarredRouteLayer = layer;
            else routeGroup = layer;

            // draw the route
            L.geoJSON(featureCollection, { style: { color: '#003c8f', weight: 8, opacity: 1 } }).addTo(layer);
            L.geoJSON(featureCollection, { style: { color: '#4da6ff', weight: 4, opacity: 1 } }).addTo(layer);

            layer.addTo(map);


            const coords = stitchEdges(featureCollection.features);
            startMarker = L.marker([coords[0][1], coords[0][0]], { icon: startIcon }).addTo(map);
            endMarker = L.marker([coords[coords.length - 1][1], coords[coords.length - 1][0]], { icon: endIcon }).addTo(map);
            destinationMarker = L.marker([coords[coords.length - 1][1], coords[coords.length - 1][0]], { icon: destinationIcon }).addTo(map);

            map.invalidateSize();

            let fitOptions = {};
            
            // apply extra padding only on mobile (max-width 768px)
            if (window.innerWidth <= 768) {
                let topPadding = 70;
                let bottomPadding = 70;
                let leftPadding = 10;
                let rightPadding = 10;

                fitOptions.paddingTopLeft = [leftPadding, topPadding];
                fitOptions.paddingBottomRight = [rightPadding, bottomPadding];
                fitOptions.maxZoom = 20;
            } else {
                fitOptions.paddingTopLeft = [300, 20];
                fitOptions.paddingBottomRight = [20, 20];
                fitOptions.maxZoom = 20;
            }

            // determine which layer to use for fitBounds
            const boundsLayer = routeObj ? activeStarredRouteLayer : routeGroup;

            // zoom only if the layer has content
            if (boundsLayer && boundsLayer.getBounds && boundsLayer.getBounds().isValid()) {
                map.fitBounds(boundsLayer.getBounds(), fitOptions);
            }
        }

        // show route 1 by default
        showRoute({ rank: 1 });

        // if node is temporarily removed, let user know it's being fixed (can't report)
        function showFixingBox(nodeId, type, name, building, lat, lng) {
            var boxHtml = `
                <div id="fixingBox" class="fixing-box">
                    This ${type} is being fixed!
                </div>
            `;

            L.popup({
                closeButton: false,
                autoClose: true,
                className: "fixing-popup"
            })
                .setLatLng([lat, lng])
                .setContent(boxHtml)
                .openOn(map);
        }

        // otherwise, user can submit a report
        function showReportForm(nodeId, type, name, building, lat, lng) {
            var formHtml = `
                <div id="reportForm" class="report-form">
                    <h5 class="report-title">Report ${building} ${name}</h5>
                    
                    <textarea id="reportDesc" 
                            class="report-textarea" 
                            placeholder="Brief description" 
                            rows="3" 
                            maxlength="255"></textarea>
                    
                    <div class="report-actions">
                        <button class="btn-submit" 
                                onclick="submitReport(${nodeId}, '${name}', '${building}')">
                            Submit
                        </button>
                    </div>
                    
                    <div class="report-contact">
                        <a href="tel:+14104552550" class="report-link">
                            <span class="phone-icon">🕻</span> Call Work Control
                        </a>
                    </div>
                </div>
            `;

            L.popup()
                .setLatLng([lat, lng])
                .setContent(formHtml)
                .openOn(map);
        }

        function closeReportForm() {
            map.closePopup();
        }

        function submitReport(nodeId, name, building) {
            var description = document.getElementById("reportDesc").value;
            fetch("/submit-report", {
                method: "POST",
                headers: {"Content-Type": "application/json"},
                body: JSON.stringify({
                node_id: nodeId, 
                node_name: name,
                building: building,
                description: description})
            })
            .then(res => res.json())
            .then(data => {
                alert("Report submitted!");
                closeReportForm();
            })
            .catch(err => console.error(err));
        }

        function submitRouteRequest() {
            let startBuilding = document.getElementById("start_building").value;
            let startLevel = document.getElementById("start_level").value;
            let destBuilding = document.getElementById("dest_building").value;
            let destLevel = document.getElementById("dest_level").value;

            if (!startBuilding || !startLevel || !destBuilding || !destLevel) {
                alert("Please fill out all fields.");
                return;
            }

            const url = `/select?start_building=${encodeURIComponent(startBuilding)}`
                    + `&start_level=${encodeURIComponent(startLevel)}`
                    + `&dest_building=${encodeURIComponent(destBuilding)}`
                    + `&dest_level=${encodeURIComponent(destLevel)}`;

            window.location.href = url;
        }

        let userMarker = null;

        function updateUserMarker(lat, lng) {
            if (userMarker) {
                // update existing marker position
                userMarker.setLatLng([lat, lng]);
            } else {
                // create marker
                userMarker = L.circleMarker([lat, lng], {
                    radius: 8,
                    fillColor: "#007bff",
                    color: "#fff",
                    weight: 2,
                    opacity: 1,
                    fillOpacity: 0.8
                }).addTo(map).bindPopup("You are here");
            }
        }

        // get user's current location
        function initGeolocation() {
            if (navigator.geolocation) {
                navigator.geolocation.watchPosition(
                function(position) {
                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;
                    updateUserMarker(lat, lng);
                },
                function(error) {
                    console.error("Error getting location:", error);
                },
                {
                enableHighAccuracy: true,
                maximumAge: 0,
                timeout: 5000
                }
            );
            } else {
                alert("Geolocation is not supported by this browser.");
            }
        }

        document.addEventListener("DOMContentLoaded", initGeolocation);

        // called when user clicks the star icon
        async function starRoutePrompt(rank) {
            const starImg = document.getElementById("star-" + rank);
            const routeObj = routes[rank];

            if (!routeObj) {
                alert("Route data missing.");
                return;
            }

            if (starImg.dataset.starred === "true") {
                alert("You have already starred this route.");
                return;
            }
            console.log("RouteObj", routeObj);

            const startBldg = routeObj.start_building || "Start";
            const endBldg = routeObj.end_building || "End";
            const suggested = `${startBldg}->${endBldg}`;

            let customName = prompt(
                "Enter a name for this route (or leave blank to use suggested name):\nSuggested: " + suggested
            );

            if (customName === null) return;

            customName = customName.trim() || suggested;

            if (customName.length > 100) {
                alert("Name must be 100 characters or fewer.");
                return;
            }

            try {
                let directionsData = null;
                if (routeObj.pgr_path_id) {
                    const resp = await fetch(`/directions/${routeObj.pgr_path_id}`);
                    if (resp.ok) {
                        directionsData = await resp.json();
                    } else {
                        console.warn("Could not fetch directions, continuing without them.");
                    }
                }

                const starResp = await fetch("/star-route", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        name: customName,
                        rank: routeObj.rank,
                        route_json: {
                            geoms: routeObj.geoms
                        },
                        directions: directionsData,
                        pgr_path_id: routeObj.pgr_path_id || null
                    })
                });

                const starData = await starResp.json();

                if (starData.success) {
                    starImg.dataset.starred = "true";
                    starImg.src = "/static/FavFill.png";
                    alert("Route starred successfully!");
                } else if (starData.error === "Route already starred") {
                    alert("You have already starred this route.");
                } else {
                    console.error("Star error:", starData.error);
                    alert("Error starring route.");
                }

            } catch (err) {
                console.error("Star route error:", err);
                alert("Error starring route.");
            }
        }

        document.addEventListener("DOMContentLoaded", () => {
            for (let rank in routes) {
                let starImg = document.getElementById("star-" + rank);
                if (!starImg) continue;

                starImg.src = "/static/FavFill.png";

                if (!starImg.dataset.starred) {
                    starImg.dataset.starred = "false";
                }

                // star button handler
                starImg.addEventListener("click", () => starRoutePrompt(rank));
            }
        });

        let selectedRoute = null;

        function selectRoute(rank) {
            // clear previous selection
            document.querySelectorAll(".routeCard").forEach(card => {
                card.classList.remove("selected");
            });

            // mark this one as selected
            let card = document.getElementById("route-" + rank);
            if (card) {
                card.classList.add("selected");
                selectedRoute = String(rank);

                // clear starred route selection
                activeStarredRouteId = null;
                window.selectedStarredRoute = null;

                showRoute({ rank: selectedRoute });
            }
        }

        // zoom back to UMBC campus
        function zoomUMBC() {
            map.setView([39.25531911376339, -76.71396732330324], 16);
        }

        // zoom to user location
        function zoomToUser() {
            if (userMarker) {
                map.setView(userMarker.getLatLng(), 17);
            } else {
                alert("Your location isn't available yet.");
            }
        }
    </script>
</body>
</html>

